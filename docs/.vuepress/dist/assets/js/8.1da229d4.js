(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{210:function(a,e,n){"use strict";n.r(e);var s=n(28),t=Object(s.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("p",[a._v("通常处理异步会使用三种方案： 1、回调函数 2、promise 3、async、await")]),a._v(" "),n("h1",{attrs:{id:"回调函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[a._v("#")]),a._v(" 回调函数")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function ajax(callBack) {\n    setTimeout(() => {\n        callBack()\n    }, 2000)\n}\n\najax(() => {\n    console.log(1)\n})\n")])])]),n("p",[a._v("回调函数是最通俗易懂的，但是回调函数一多就会出现所谓的回调地狱，代码非常丑陋且难以理解")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function ajax(callBack) {\n    setTimeout(() => {\n        callBack()\n    }, 2000)\n}\n\najax(() => {\n    ajax(() => {\n        ajax(() => {\n            ajax(() => {\n                ajax(() => {\n                    console.log(1)\n                })\n            })\n        })\n    })\n})\n")])])]),n("h1",{attrs:{id:"promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise")]),a._v(" "),n("p",[a._v("Promise 是异步编程的一种解决方案，比传统的回调函数更强大、更优雅。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function ajax() {\n    return new Promise((resolve, reject) => {\n        try {\n            setTimeout(() => {\n                resolve()\n            }, 2000)\n        } catch (err) {\n            reject(err)\n        }\n    })\n}\n\najax().then(() => {\n    console.log('success')\n}).catch(err => {\n    console.log(err)\n})\n")])])]),n("p",[n("strong",[a._v("高级用法")])]),a._v(" "),n("p",[a._v("一、 Promise.all")]),a._v(" "),n("p",[a._v("Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。需要传入一个数组作为参数")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("const p = Promise.all([p1, p2, p3]);\n")])])]),n("p",[a._v("Promise.all 的两种状态：")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("只有当p1、p2、p3状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数")])]),a._v(" "),n("li",[n("p",[a._v("只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数")])])]),a._v(" "),n("p",[a._v("二、Promise.race")]),a._v(" "),n("p",[a._v("Promise.race 用法与 Promise.all 类似，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。")]),a._v(" "),n("h1",{attrs:{id:"async-函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#async-函数"}},[a._v("#")]),a._v(" async 函数")]),a._v(" "),n("p",[a._v("ES2017 标准引入了 async 函数，使得异步操作变成同步写法。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("async function asyncFn() {\n    await ajax()\n    // do something\n    console.log(1)\n}\n\nfunction ajax() {\n    return new Promise((resolve, reject) => {\n        try {\n            setTimeout(() => {\n                resolve()\n            }, 2000)\n        } catch (err) {\n            reject(err)\n        }\n    })\n}\n\nasyncFn()\n")])])]),n("p",[a._v("await 后面做异步操作，需要注意的是 await 后面需要是一个 Promise 对象")])])}),[],!1,null,null,null);e.default=t.exports}}]);