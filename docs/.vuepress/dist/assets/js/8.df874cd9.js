(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{208:function(a,n,e){"use strict";e.r(n);var t=e(28),s=Object(t.a)({},(function(){var a=this,n=a.$createElement,e=a._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("通常处理异步会使用三种方案：")]),a._v(" "),e("ol",[e("li",[a._v("回调函数")]),a._v(" "),e("li",[a._v("promise")]),a._v(" "),e("li",[a._v("async、await")])]),a._v(" "),e("h1",{attrs:{id:"回调函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[a._v("#")]),a._v(" 回调函数")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function ajax(callBack) {\n    setTimeout(() => {\n        callBack()\n    }, 2000)\n}\n\najax(() => {\n    console.log(1)\n})\n")])])]),e("p",[a._v("回调函数是最通俗易懂的，但是回调函数一多就会出现所谓的回调地狱，代码非常丑陋且难以理解")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function ajax(callBack) {\n    setTimeout(() => {\n        callBack()\n    }, 2000)\n}\n\najax(() => {\n    ajax(() => {\n        ajax(() => {\n            ajax(() => {\n                ajax(() => {\n                    console.log(1)\n                })\n            })\n        })\n    })\n})\n")])])]),e("h1",{attrs:{id:"promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[a._v("#")]),a._v(" Promise")]),a._v(" "),e("p",[a._v("Promise 是异步编程的一种解决方案，比传统的回调函数更强大、更优雅。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function ajax() {\n    return new Promise((resolve, reject) => {\n        try {\n            setTimeout(() => {\n                resolve()\n            }, 2000)\n        } catch (err) {\n            reject(err)\n        }\n    })\n}\n\najax().then(() => {\n    console.log('success')\n}).catch(err => {\n    console.log(err)\n})\n")])])]),e("h1",{attrs:{id:"async-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-函数"}},[a._v("#")]),a._v(" async 函数")]),a._v(" "),e("p",[a._v("ES2017 标准引入了 async 函数，使得异步操作变成同步写法。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async function asyncFn() {\n    await ajax()\n    // do something\n    console.log(1)\n}\n\nfunction ajax() {\n    return new Promise((resolve, reject) => {\n        try {\n            setTimeout(() => {\n                resolve()\n            }, 2000)\n        } catch (err) {\n            reject(err)\n        }\n    })\n}\n\nasyncFn()\n")])])]),e("p",[a._v("await 后面做异步操作，需要注意的是 await 后面需要是一个 Promise 对象")])])}),[],!1,null,null,null);n.default=s.exports}}]);