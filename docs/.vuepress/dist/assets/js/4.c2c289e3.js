(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{201:function(o,e,t){o.exports=t.p+"assets/img/proto.b57683b0.png"},209:function(o,e,t){"use strict";t.r(e);var n=t(28),r=Object(n.a)({},(function(){var o=this,e=o.$createElement,n=o._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[n("p",[o._v("每个 JavaScript 对象都有一个 "),n("strong",[o._v("proto")]),o._v(" 属性指向它的原型，同时函数的 prototype 属性也是指向它的原型，而原型的原型还有原型，直至 null 为止形成一条原型链。原型的用途的是，可以由特定类型的实例共享属性和方法。")]),o._v(" "),n("p",[o._v("举个栗子：定义一个构造函数 Person：")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("function Person() { }\n    Person.prototype.name = 'ghc'\n    Person.prototype.age = 24\n    Person.prototype.getName = function () {\n        return this.name\n    }\n    const person = new Person()\n    console.log(person)  // { }\n    console.log(person.age)  // 24\n    console.log(person.getName())  // ghc\n")])])]),n("p",[o._v("可以看到 person 实例是一个空对象，但是却可以访问到 age 属性和 getName 方法，这是因为 这些属性和方法都定义在了 person 的原型上，当代码访问 age 属性时，会执行一次搜索，搜索 age 属性，首先在实例本身开始，如果找到了 age 属性，则返回该属性，如果没有，就会继续去 搜索 person 的原型，如果找到了 age 属性，则返回该属性，如果没有，则继续向上搜索知道 null 为止。")]),o._v(" "),n("p",[n("strong",[o._v("实例、原型、构造函数之间的关系")])]),o._v(" "),n("p",[o._v("构造函数 Person 有个属性 prototype 就是构造函数的原型，这个原型默认有两个属性，一个是 constructor，一个是 "),n("strong",[o._v("proto")]),o._v("。")]),o._v(" "),n("p",[o._v("constructor 就是指向构造函数 Person，即 Person.prototype.constructor === Person")]),o._v(" "),n("p",[n("strong",[o._v("proto")]),o._v(" 指向 Person 的原型的原型（Object.prototype）")]),o._v(" "),n("p",[o._v("然而 person 实例的原型就是 Person 构造函数的原型，即 Object.getPrototypeOf(person) === Person.prototype")]),o._v(" "),n("p",[o._v("具体逻辑如下图：")]),o._v(" "),n("p",[n("img",{attrs:{src:t(201),alt:"An image"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);